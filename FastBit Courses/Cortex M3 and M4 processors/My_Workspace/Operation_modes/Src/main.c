/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#define FAULT		1

#if !defined(__SOFT_FP__) && defined(__ARM_FP) && 0
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void generate_interrupt(void);

void change_access_level_unpriv(void);

extern void initialise_monitor_handles(void);

volatile int ipsr_value;

int main(void){
	initialise_monitor_handles();
	printf("Before interrupt\n");

#if FAULT
	change_access_level_unpriv();
#else
#endif

	generate_interrupt();
#if FAULT
	initialise_monitor_handles();
	printf("Exception handled. Resuming ISR or Handler\n");
#endif
	initialise_monitor_handles();
	printf("After interrupt\n");

	for(;;);
}

void generate_interrupt(void){
	uint32_t volatile *pISER0 = (uint32_t *)(0xE000E100);
	uint32_t volatile *pSTIR  = (uint32_t *)(0xE000EF00);

	*pISER0 |= (1U << 3);
	*pSTIR	|= (0x03 & 0x1FF);
}

void change_access_level_unpriv(void){
	unsigned int volatile tmp;
	__asm volatile("MRS %0, CONTROL":"=r"(tmp));
	tmp |= 0x01;
	__asm volatile("MSR CONTROL, %0": :"r"(tmp));
}
void RTC_WKUP_IRQHandler(void)
{
	initialise_monitor_handles();
	printf("Handler mode\n");
	__asm volatile(
			"MRS %[reg], IPSR"
			:[reg] "=r" (ipsr_value)
			);
	initialise_monitor_handles();
	printf("IRQ%d occured\n", ((ipsr_value & 0x1FF) - 16));

}

void HardFault_Handler(void)
{
	__asm volatile("LDR R5, =#0x04");
	unsigned int volatile tmp;
	__asm volatile("MRS %0, CONTROL":"=r"(tmp));
	tmp &= ~0x01;
	__asm volatile("MSR CONTROL, %0": :"r"(tmp));

}
