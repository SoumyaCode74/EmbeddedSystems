/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP) && 0
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void fun_add(void);
volatile static int result;
void saturating_add(int, int);
void data_copy(uint32_t *, uint32_t, uint32_t);
int main(void)
{
    /* Loop forever */
	fun_add();
	saturating_add(5, 10);

	printf("Saturating addition");
	uint32_t * pAddr = (uint32_t *)(0x20000002);
	data_copy(pAddr, 0x48, 0x20000004);
}

void fun_add(void)
{
	__asm volatile(
			"LDR R1,=#0x20000000\n\t"
			"LDR R2,=#0x20000004\n\t"
			"LDR R3,=#0x20000008\n\t"
			"LDR R0,=#0x04\n\t"
			"STR R0,[R1]\n\t"
			"LDR R0,=#0x08\n\t"
			"STR R0,[R2]\n\t"
			"LDR R0,[R1]\n\t"
			"LDR R1,[R2]\n\t"
			"ADD R4,R0,R1\n\t"
			"STR R4,[R3]\n\t"
			);


}

void saturating_add(int a, int b) {
__asm volatile(
// The assembly string uses templates for the registers which hold output
// and input values. These will be replaced with the names of the
// registers that the compiler chooses to hold the output and input
// values.
"qadd %[res], %[lhs], %[rhs]"
//"qadd %0, %1, %2"
// The output operand, which corresponds to the "result" variable. This
// does not have a name assigned, so must be referred to in the assembly
// string by its number ("%0").
// The "=" character in the constraint string tells the compiler that the
// register chosen to hold the result does not need to have any
// particular value at the start of the inline assembly.
// The "r" character in the constraint tells the compiler that the value
// should be placed in a general-purpose register (r0-r12 or r14).
: [res] "=r" (result)
// The two input operands also use the "r" character in their
// constraints, so the compiler will place them in general-purpose
// registers.
// These have names specified, which can be used to refer to them in
// the assembly string ("%[lhs]" and "%[rhs]").
 : [lhs] "r" (a), [rhs] "r" (b)
//  : "r" (a), "r" (b)
  );
 }

void data_copy(uint32_t *src, uint32_t srcdata, uint32_t destination){
	__asm volatile(
		"LDR R0,[%[src]]"
		: : [src] "r"(src)
		);
	__asm volatile(
		"MOV R1,%[srcdata]"
		: : [srcdata] "r"(srcdata)
		);
	__asm volatile(
		"LDR R2,[%[dest]]"
		: : [dest] "r"(destination)
		);
	__asm volatile(
		"ADD R4,R1,R1"
		);
	__asm volatile(
		"STR R4,[%[dest]]"
		: : [dest] "r"(destination)
		);
}
