/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/*
 * Write a program to execute an SVC instruction from thread mode
 * Trigger the SVC exception from main thread
 * Write a naked function to obtain the MSP
 * Follow the MSP to get the SVC number used, by retrieving the return address
 * Set the mode of the pins of GPIO Port D to all outputs.
 * Save the value in the 1st byte of GPIOD_DR register with DR.0 as LSB
 * Increment the SVC by 4. Save the value to the 2nd byte of GPIOD_DR register.
 * Return it to the main thread
 */

#include <stdint.h>
#define PERIPH_BASE					(0x40020000UL)
#define RCC_AHB1ENR					(*(uint32_t *)(PERIPH_BASE+0X3800+0X30))
#define GPIOD_MODER					(*(uint32_t *)(PERIPH_BASE+0X0C00+0X00))
#define GPIOD_ODR					(*(uint32_t *)(PERIPH_BASE+0X0C00+0X14))
#define CPACR						(*(uint32_t *)(0xE000ED88U))
#define CFSR						(*(uint32_t *)(0xE000ED28U))

/*The following macro to handle division-by-zero situation*/
#define DIV_BY_ZERO       			1
/* Macro FIRST_OPERAND for value of variable 'a' */
#define FIRST_OPERAND				100
/* Macro FIRST_OPERAND for value of variable 'b' */
#define SECOND_OPERAND				0
/* Macro CHOICE for Supervisor call number */
#define CHOICE						39

//Define the register pointers to configure division-by-zero fault
#if DIV_BY_ZERO
#define CCR							(*(uint32_t *)(0xE000ED14U))
#define SHCRS						(*(uint32_t *)(0xE000ED24U))
#endif

#if !defined(__SOFT_FP__) && defined(__ARM_FP) && 0
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int32_t a = FIRST_OPERAND;
int32_t b = SECOND_OPERAND;

int32_t addition(int32_t, int32_t);
int32_t subtraction(int32_t, int32_t);
int32_t multiplication(int32_t, int32_t);
int32_t division(int32_t, int32_t);

void delay(uint32_t);

int main(void)
{
	//Enable clock source to GPIOD peripheral at AHB1 bus
	RCC_AHB1ENR |= (1U << 3);
	/*Set direction of onboard LEDs to general output as follows:
	 * First reset bit positions 31:24
	 * Set 0b01010101 to bit positions 31:24
	 */
	GPIOD_MODER &= ~(0xFF << 24);
	GPIOD_MODER |=  (0b01010101 << 24);

#if DIV_BY_ZERO
	/* Enable usage fault handler */
	SHCRS |= (1U << 18);
	/* Enable trap divide by zero exception */
	CCR   |= (1U << 4);
#endif


	uint8_t choice = CHOICE;
	int32_t *pResult = (int32_t *)0x20000010;
	/* Load the operands in R1 and R2 core registers */
	/* This will allow the SVC handler program to retrieve from stack frame */
	/*Raise SVC exception with the following SVC numbers
	 * For addition, use #36
	 * For subtraction, use #37
	 * For multiplication, use #38
	 * For division, use #39
	 */
//	__asm volatile("SVC R0");
	switch(choice){
		case 36:
			__asm volatile("SVC #36");
			break;
		case 37:
			__asm volatile("SVC #37");
			break;
		case 38:
			__asm volatile("SVC #38");
			break;
		case 39:
			__asm volatile("SVC #39");
			break;
		default:
			/* If none of the choices are valid, manually pend the usage exception */
			SHCRS |= (1U << 12);
	}
	/* Save result to SRAM position at address pointed by pResult */
	__asm volatile("STR R0,[%[des]]"::[des]"r"(pResult));
	/* Turn ON onboard GREEN LED at PD12 for successful operation*/
	GPIOD_ODR |= (1U << 12);
	/* Loop forever */
	for(;;);
}
/*
 * Reason for making the SVC Handler function a naked one
 * Had it not been naked, the MSP value would be tampered
 * by the prologue statements of the SVC Handler because of
 * stacking process
 * To override the stacking at the time of handling and retrieve
 * the MSP, this is the solution
 */
__attribute__ ((naked)) void SVC_Handler(void){
	__asm volatile("MOV R8,%[op1]"::[op1]"r"(a));
	__asm volatile("MOV R9,%[op2]"::[op2]"r"(b));
	__asm volatile("MRS R0,MSP");
	__asm volatile("B SVC_Handler_c");
}

void SVC_Handler_c(uint32_t *pBaseStackAddress){
	/*Retrieve the SVC number
	 * First, get the return address from stack using stack pointer
	 * Then, obtain the SVC number
	 */

	/* Return address */
	uint8_t *pReturnAddr = (uint8_t *)*(pBaseStackAddress+6);
	/* Move back 2 bytes and get the SVC number */
	uint8_t SVC_number = *(pReturnAddr - 2);

	/*Retrieve the operand values and store in local variables
	 * Load from R1 stack position to local variable a
	 * Load from R2 stack position to local variable b
	 */
	int32_t a1; //First operand of operation
	int32_t a2; //Second operand of operation
	int32_t result; //Variable to store result of operation
	/* Load from R1 stacked value to local variable a */
//	__asm volatile("LDR %[dest],[%[src]]":[dest]"=r"(a1):[src]"r"(pBaseStackAddress + 1));
	/* Load from R2 stacked value to local variable b */
//	__asm volatile("LDR %[dest],[%[src]]":[dest]"=r"(a2):[src]"r"(pBaseStackAddress + 2));

	/*Perform math operation
	 * Match SVC_number against desired operation
	 * For valid match, first turn OFF GREEN LED, perform operation.
	 * Save the result of operation in R3 position of stack frame
	 * Turn ON GREEN LED
	 * For invalid valid match, raise HardFault exception
	 */
	CPACR |= (0x0F << 20);
	switch (SVC_number)
	{
		case 36:
			/* Turn OFF GREEN LED connected to PD12 */
			/* Load from R1 stacked value to local variable a */
			__asm volatile("MOV %[dest],R8":[dest]"=r"(a1));
			/* Load from R2 stacked value to local variable b */
			__asm volatile("MOV %[dest],R9":[dest]"=r"(a2));

			GPIOD_ODR &= ~(1U << 12);
			/* Perform operation */
			result = addition(a1, a2);
			break;
		case 37:
			__asm volatile("MOV %[dest],R8":[dest]"=r"(a1));
			/* Load from R2 stacked value to local variable b */
			__asm volatile("MOV %[dest],R9":[dest]"=r"(a2));

			/* Turn OFF GREEN LED connected to PD12 */
			GPIOD_ODR &= ~(1U << 12);
			/* Perform operation */
			result = subtraction(a1, a2);
			break;
		case 38:
			__asm volatile("MOV %[dest],R8":[dest]"=r"(a1));
			/* Load from R2 stacked value to local variable b */
			__asm volatile("MOV %[dest],R9":[dest]"=r"(a2));

			/* Turn OFF GREEN LED connected to PD12 */
			GPIOD_ODR &= ~(1U << 12);
			/* Perform operation */
			result = multiplication(a1, a2);
			break;
		case 39:
			__asm volatile("MOV %[dest],R8":[dest]"=r"(a1));
			/* Load from R2 stacked value to local variable b */
			__asm volatile("MOV %[dest],R9":[dest]"=r"(a2));

			/* Turn OFF GREEN LED connected to PD12 */
			GPIOD_ODR &= ~(1U << 12);
			/* Perform operation */
			result = division(a1, a2);
			break;
	}
	/* Save the result in R3 position in stack */
	*(pBaseStackAddress) = result;
}

void UsageFault_Handler(void){
	/* Check for division-by-zero exception */
	if (CFSR & (1U << 25)){
		/* Turn ON the onboard BLUE LED if division by zero is entrapped */
		GPIOD_ODR |= (1U << 15);
	}
	else{
		/* Turn ON the onboard RED and BLUE LEDs for other exceptions */
		GPIOD_ODR |= (1U << 14);
		GPIOD_ODR |= (1U << 15);
	}
}

void HardFault_Handler(void){
	if (CFSR & (1U << 25)){
		/* Turn ON the onboard BLUE AND ORANGE LEDs if division by zero if entrapped through hardfault */
		GPIOD_ODR |= (1U << 15);
		GPIOD_ODR |= (1U << 13);
	}
	else{
	/* Turn ON the RED AND ORANGE LEDs for other exceptions*/
	GPIOD_ODR |= (1U << 14);
	GPIOD_ODR |= (1U << 13);
	}
}

void delay(uint32_t count){
	count = (uint32_t)(0.5*count*(count+1));
	for(uint32_t volatile i = 0; i < count; i++);
}
