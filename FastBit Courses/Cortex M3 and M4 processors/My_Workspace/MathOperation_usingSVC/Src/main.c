/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/*
 * Write a program to execute an SVC instruction from thread mode
 * Trigger the SVC exception from main thread
 * Write a naked function to obtain the MSP
 * Follow the MSP to get the SVC number used, by retrieving the return address
 * Set the mode of the pins of GPIO Port D to all outputs.
 * Save the value in the 1st byte of GPIOD_DR register with DR.0 as LSB
 * Increment the SVC by 4. Save the value to the 2nd byte of GPIOD_DR register.
 * Return it to the main thread
 */

#include <stdint.h>
#define PERIPH_BASE					(0x40020000UL)
#define RCC_AHB1ENR					(*(uint32_t *)(PERIPH_BASE+0X3800+0X30))
#define GPIOD_MODER					(*(uint32_t *)(PERIPH_BASE+0X0C00+0X00))
#define GPIOD_ODR					(*(uint32_t *)(PERIPH_BASE+0X0C00+0X14))
#define CPACR						(*(uint32_t *)(0xE000ED88U))
#define CFSR						(*(uint32_t *)(0xE000ED28U))

//The following macro to handle division-by-zero situation
#define DIV_BY_ZERO       			1

//Define the register pointers to configure division-by-zero fault
#if DIV_BY_ZERO
#define CCR							(*(uint32_t *)(0xE000ED14U))
#define SHCRS						(*(uint32_t *)(0xE000ED24U))
#endif

#if !defined(__SOFT_FP__) && defined(__ARM_FP) && 0
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int32_t addition(int32_t, int32_t);
int32_t subtraction(int32_t, int32_t);
int32_t multiplication(int32_t, int32_t);
float division(int32_t, int32_t);

void delay(uint32_t);

int main(void)
{
	//Enable clock source to GPIOD peripheral at AHB1 bus
	RCC_AHB1ENR |= (1U << 3);
	/*Set direction of onboard LEDs to general output as follows:
	 * First reset bit positions 31:24
	 * Set 0b01010101 to bit positions 31:24
	 */
	GPIOD_MODER &= ~(0xFF << 24);
	GPIOD_MODER |=  (0b01010101 << 24);

#if DIV_BY_ZERO
	/* Enable usage fault handler */
	SHCRS |= (1U << 18);
	/* Enable trap divide by zero exception */
	CCR   |= (1U << 4);
#endif


	int32_t a = 5;
	int32_t b = 3;
	int32_t *pResult = (int32_t *)0x20000010;
	/* Load the operands in R1 and R2 core registers */
	/* This will allow the SVC handler program to retrieve from stack frame */
	__asm volatile("MOV R1,%[op1]"::[op1]"r"(a));
	__asm volatile("MOV R2,%[op2]"::[op2]"r"(b));
	/*Raise SVC exception with the following SVC numbers
	 * For addition, use #36
	 * For subtraction, use #37
	 * For multiplication, use #38
	 * For division, use #39
	 */
	__asm volatile("SVC #39"); //Perform operation from SVC
	/* Save result to SRAM position at address pointed by pResult */
	__asm volatile("STR R0,[%[des]]"::[des]"r"(pResult));
	/* Turn ON onboard GREEN LED at PD12 for successful operation*/
	GPIOD_ODR |= (1U << 12);
	/* Loop forever */
	for(;;);
}
/*
 * Reason for making the SVC Handler function a naked one
 * Had it not been naked, the MSP value would be tampered
 * by the prologue statements of the SVC Handler because of
 * stacking process
 * To override the stacking at the time of handling and retrieve
 * the MSP, this is the solution
 */
__attribute__ ((naked)) void SVC_Handler(void){
	__asm volatile("MRS R0,MSP");
	__asm volatile("B SVC_Handler_c");
}

void SVC_Handler_c(uint32_t *pBaseStackAddress){
	/*Retrieve the SVC number
	 * First, get the return address from stack using stack pointer
	 * Then, obtain the SVC number
	 */

	/* Return address */
	uint8_t *pReturnAddr = (uint8_t *)*(pBaseStackAddress+6);
	/* Move back 2 bytes and get the SVC number */
	uint8_t SVC_number = *(pReturnAddr - 2);

	/*Retrieve the operand values and store in local variables
	 * Load from R1 stack position to local variable a
	 * Load from R2 stack position to local variable b
	 */
	uint32_t a; //First operand of operation
	uint32_t b; //Second operand of operation
	float result; //Variable to store result of operation
	/* Load from R1 stacked value to local variable a */
	__asm volatile("LDR %[dest],[%[src]]":[dest]"=r"(a):[src]"r"(pBaseStackAddress + 1));
	/* Load from R2 stacked value to local variable b */
	__asm volatile("LDR %[dest],[%[src]]":[dest]"=r"(b):[src]"r"(pBaseStackAddress + 2));

	/*Perform math operation
	 * Match SVC_number against desired operation
	 * For valid match, first turn OFF GREEN LED, perform operation.
	 * Save the result of operation in R3 position of stack frame
	 * Turn ON GREEN LED
	 * For invalid valid match, raise HardFault exception
	 */
	CPACR |= (0x0F << 20);
	switch (SVC_number)
	{
		case 36:
			/* Turn OFF GREEN LED connected to PD12 */
			GPIOD_ODR &= ~(1U << 12);
			/* Perform operation */
			result = addition(a, b);
			break;
		case 37:
			/* Turn OFF GREEN LED connected to PD12 */
			GPIOD_ODR &= ~(1U << 12);
			/* Perform operation */
			result = subtraction(a, b);
			break;
		case 38:
			/* Turn OFF GREEN LED connected to PD12 */
			GPIOD_ODR &= ~(1U << 12);
			/* Perform operation */
			result = multiplication(a, b);
			break;
		case 39:
			/* Turn OFF GREEN LED connected to PD12 */
			GPIOD_ODR &= ~(1U << 12);
			/* Perform operation */
			result = division(a, b);
			break;
	}
	/* Save the result in R3 position in stack */
	*(pBaseStackAddress) = result;
}

void UsageFault_Handler(void){
	/* Check for division-by-zero exception */
	if (CFSR & (1U << 25)){
		/* Turn ON the onboard BLUE LED if detected */
		GPIOD_ODR |= (1U << 15);
	}
	else{
		/* Turn ON the onboard ORANGE and RED LEDs for other exceptions */
		GPIOD_ODR |= (1U << 13);
		GPIOD_ODR |= (1U << 14);
	}
}

void HardFault_Handler(void){
	if (CFSR & (1U << 25)){
		/* Turn ON the onboard BLUE LED if detected */
		GPIOD_ODR |= (1U << 15);
	}
	else{
	/* Turn ON and OFF the RED LED */
	GPIOD_ODR |= (1U << 14); // Turn ON
	delay(50); //Wait for some time
	GPIOD_ODR &= ~(1U << 14); //Turn OFF
	delay(50); //Wait for some time
	}
}

void delay(uint32_t count){
	count = (uint32_t)(0.5*count*(count+1));
	for(uint32_t volatile i = 0; i < count; i++);
}
